磁盘 I/O 和网络 I/O

## I/O 基础介绍

I/O 在系统层面会有 2 个阶段

- 第一个阶段是**读取文件**，将**文件放入操作系统内核缓冲区**；
- 第二阶段是将**内核缓冲区拷贝到应用程序地址空间**。

#### 阻塞 I/O

例如读取一个文件，我们必须要**等待文件读取完成后**，也就是完成上面所说的两个阶段，才能执行其他逻辑，而当前是无法释放 CPU 的，因此无法去处理其他逻辑。

#### 非阻塞 I/O

非阻塞的意思是，我们发起了一个读取文件的指令，系统会返回正在处理中，然后这时候如果要释放进程中的 CPU 去处理其他逻辑，你就必须间隔一段时间，然后不停地去询问操作系统，使用轮询的判断方法看是否读取完成了。

#### 多路复用 I/O

主要是为了解决**轮询调度的问题**，我们可以将这些 I/O Socket 处理的结果统一交给一个独立线程来处理，当 I/O Socket 处理完成后，就主动告诉业务，处理完成了，这样不需要每个业务都来进行轮询查询了。

**它包括目前常见的三种类型：select 、poll 和 epoll**。首先 **select 是比较旧的**，它和 poll 的区别在于 poll 使用的是链表来保存 I/O Socket 数据，而 select 是数组，因此 select 会有上限 1024，而 poll 则没有。select、poll 与 epoll 的区别在于，前两者不会告诉你是哪个 I/O Socket 完成了，而 epoll 会通知具体哪个 I/O Socket 完成了哪个阶段的操作，这样就不需要去遍历查询了。

当然这里有一个重点是这三者**只会告知文件读取进入了操作系统内核缓冲区**，也就是上面我们所说的第一阶段，但是第二阶段从内核拷贝到应用程序地址空间还是同步等待的。

#### 信号驱动 I/O

这种模式和多路复用的区别在于**不需要有其他线程来处理**，而是在完成了读取进入操作系统内核缓冲区后，立马通知，也就是第一阶段可以由系统层面来处理，不需要独立线程来管理，但是第二阶段还是和多路复用一样。

#### 异步 I/O

和信号驱动不同的是，异步 I/O 是**两个阶段都完成了以后**，**才会通知**，并不是第一阶段完成。

我们常说的Node.js 是一个异步 I/O 这个是没有错的。具体来说 Node.js 是其 libv 库自行实现的一种类似异步 I/O 的模型，对于 Node.js 应用来说是一个异步 I/O，因此无须处理两个过程，而在 libv 内部实现，则是多线程的一个 epoll 模型。这点是非常重要的，希望你可以牢记。

### 本地磁盘 I/O

- 如果是**写 I/O**，并且不需要获取写入结果时，则**不需要进行回调处理**，减少主线程压力，比如最常见的例子就是写日志
- 如果是**写 I/O**，可以**使用文件流的方式**，避免重复的打开同一个文件，损耗不必要的打开和关闭文件的过程；
- 如果是**写 I/O**，为了缓解写并发对系统的压力，可以将需要写入的日志放入一个**临时内存**中，从而降低系统并发处理压力，从而降低系统负载;
- 如果是**读 I/O**，并且需要获取读取结果时，能够使用缓存尽量使用缓存，因为读 I/O 是需要时间，虽然不影响主线程性能，但是会影响用户响应时间，当读 I/O 过大，则系统压力较大，从而影响整体读接口的性能，因此需要使用缓存，减少并发对系统的 I/O 压力；
- 如果是**读 I/O**，并且无法进行缓存的，则尽量考虑不使用本地磁盘 I/O 操作；
- 如果是**读 I/O**，涉及大文件读取操作时，则应使用数据流的方式，而不是一次性读取内存中进行处理。

### 网络 I/O

1. **减少与网络 I/O 的交互**，比如缓存已获取的内容；
2. 使用**更高性能的网络 I/O** 替代其他性能较差的、成本更高的网络 I/O 类型，比如数据库读写的 I/O 成本是明显高于缓存型的，因此可以使用缓存型网络 I/O 替换存储型；
3. 